on:
  watch:
    types: started
jobs:
  prepare_release:
    runs-on: ubuntu-22.04
    if: github.event.repository.owner.id == github.event.sender.id
    steps:
    - name: Get release tag
      id: release_tag
      run: |
        release_tag="alpine-$(date +%Y-%m-%d)"
        echo "##[set-output name=release_tag;]$release_tag"

    - name: Create empty release
      id: release
      uses: softprops/action-gh-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ steps.release_tag.outputs.release_tag }}
        draft: false
        prerelease: false
    outputs:
      release_tag: ${{ steps.release_tag.outputs.release_tag }}
      upload_url: ${{ steps.release.outputs.upload_url }}

  build_alpine:
    needs: prepare_release
    runs-on: ubuntu-22.04
    if: github.event.repository.owner.id == github.event.sender.id
    steps:
    - name: Checkout
      uses: actions/checkout@main

    - name: Initialization environment
      env:
        DEBIAN_FRONTEND: noninteractive
      run: |
        sudo rm -rf /etc/apt/sources.list.d
        wget https://raw.githubusercontent.com/friendlyarm/build-env-on-ubuntu-bionic/master/install.sh
        sed -i -e 's/^apt-get -y install openjdk-8-jdk/# apt-get -y install openjdk-8-jdk/g' install.sh
        sed -i -e 's/^\[ -d fa-toolchain \]/# [ -d fa-toolchain ]/g' install.sh
        sed -i -e 's/^(cat fa-toolchain/# (cat fa-toolchain/g' install.sh
        sed -i -e 's/^(tar xf fa-toolchain/# (tar xf fa-toolchain/g' install.sh
        sudo -E bash ./install.sh
        sudo -E git config --global user.name 'GitHub Actions'
        sudo -E git config --global user.email 'noreply@github.com'
        mkdir -p ./artifact
        sudo swapoff -a
        sudo rm -rf /usr/share/dotnet /usr/local/lib/android/sdk /usr/local/share/boost /opt/ghc
        echo "cores: $(nproc)"


    - name: Download alpine-minirootfs
      run: |
        mkdir project
        cd project
        wget https://dl-cdn.alpinelinux.org/alpine/v3.23/releases/aarch64/alpine-minirootfs-3.23.2-aarch64.tar.gz
        mkdir rootfs
        sudo -E tar xzfp alpine-minirootfs-3.23.2-aarch64.tar.gz --numeric-owner --same-owner -C rootfs

- name: Apply customizations
      run: |
        sudo -u root bash -c '
          cd project
          # 1. 基础环境准备
          cp /etc/resolv.conf rootfs/etc/resolv.conf
          mkdir -p rootfs/etc/dnsmasq.d
          mkdir -p rootfs/etc/nftables.d

          # 核心安全操作：在宿主机层面直接为 rootfs 注入 bash
          LANG=C chroot rootfs /bin/sh -c "apk update && apk add --no-cache bash"
          
          # 2. 注入自定义脚本 (确保路径 ../scripts/ 正确)
          cp -rv ../scripts/bin/* rootfs/usr/local/bin/
          chmod +x rootfs/usr/local/bin/*
          # 注入welcome脚本
          cp ../scripts/welcome.sh rootfs/etc/profile.d/
          chmod +x rootfs/etc/profile.d/welcome.sh
        
          # 2.1 将 repo 的 config 目录下所有内容同步到 rootfs/etc/
          if [ -d "../config" ]; then
            cp -rv ../scripts/../config/* rootfs/etc/
          fi
          # 将local.d目录下的start文件授权为可执行文件
          chmod +x rootfs/etc/local.d/*.start 2>/dev/null || true
          
          # 3. 注入安装主脚本
          cp ../scripts/setup-alpine.sh rootfs/
          
          # 4. 进入 chroot 执行安装
          source ../scripts/set_chroot_env.sh
          mount_chroot_env rootfs
          
          # 执行 setup-alpine.sh (这里包含了 rc-update add 等操作)
          LANG=C chroot rootfs /bin/bash /setup-alpine.sh

          # ===================== 优化版：配置语法与环境静态校验（替代原有启动检查） =====================
          echo -e "\n========== 开始执行环境静态校验 =========="

          # 定义清理函数（校验失败时调用）
          cleanup_on_fail() {
            umount_chroot_env rootfs
            rm -f rootfs/setup-alpine.sh
            rm -f rootfs/etc/resolv.conf
            exit 1
          }

          # 1. DNSMasq 语法校验
          echo "正在验证 dnsmasq 配置..."
          if ! chroot rootfs /bin/bash -c "dnsmasq --test"; then
            echo "❌ dnsmasq 配置文件语法错误！"
            cleanup_on_fail
          fi
          echo "✅ dnsmasq 语法校验通过"

          # 2. NFTables 语法校验
          # 即使 GitHub 内核不支持，nft -c 也能检查主文件及 include 的子文件是否存在且语法正确
          echo "正在验证 nftables 配置..."
          if ! chroot rootfs /bin/bash -c "nft -c -f /etc/nftables.conf"; then
            echo "❌ nftables 配置文件语法错误或引用文件缺失！"
            cleanup_on_fail
          fi
          echo "✅ nftables 语法校验通过"

          # 3. 开机自启软链接校验 (核心检查)
          # 验证 setup-alpine.sh 里的 rc-update 是否真正创建了启动链接
          echo "正在检查服务自启状态..."
          check_services=("sysctl" "nftables" "dnsmasq" "sing-box")
          for svc in "${check_services[@]}"; do
            if [ -L "rootfs/etc/runlevels/default/${svc}" ]; then
              echo "✅ 服务 ${svc} 已加入自启列表"
            else
              echo "❌ 错误: 服务 ${svc} 未发现自启链接，请检查 setup-alpine.sh"
              cleanup_on_fail
            fi
          done

          # 4. 关键二进制文件存在性与权限检查
          echo "正在检查关键执行文件..."
          declare -A critical_files=(
            ["/usr/sbin/dnsmasq"]="dnsmasq"
            ["/usr/sbin/nft"]="nftables"
            ["/usr/local/bin/sing-box"]="sing-box"
          )
          for file in "${!critical_files[@]}"; do
            if [ ! -f "rootfs${file}" ]; then
              echo "❌ 缺失二进制文件: ${file} (所属服务: ${critical_files[$file]})"
              cleanup_on_fail
            fi
            if [ ! -x "rootfs${file}" ]; then
              echo "⚠️ 修复执行权限: ${file}"
              chmod +x "rootfs${file}"
            fi
          done

          # 5. [新增] 网络接口配置真实性检查 (防止烧录后失联)
          echo "正在检查网络接口配置..."
          # 检查 interfaces 文件是否存在
          if [ ! -f "rootfs/etc/network/interfaces" ]; then
            echo "❌ 严重错误: 缺失 /etc/network/interfaces 文件！"
            cleanup_on_fail
          fi
          
          # 检查是否定义了 eth0 (或者你的主网口，如 wan)
          # 如果你的主网口不是 eth0，请修改下方的关键词
          if ! grep -qE "eth0|wan|br-lan" rootfs/etc/network/interfaces; then
            echo "⚠️ 警告: interfaces 文件中未发现 eth0/wan 等常见接口配置，请确认网卡名是否正确！"
            # 这里如果不确定网卡名，可以只警告不退出，或者根据你的硬件写死
          fi
          echo "✅ 网络接口配置检查完成"
          echo "✅ 所有静态校验通过！"
          # ===================== 检查逻辑结束 =====================

          # 5. 额外加固：创建 ppp.wan 符号链接
          if [ -e rootfs/etc/init.d/ppp ]; then
            ln -sf ppp rootfs/etc/init.d/ppp.wan
          fi

          # 6. 环境清理
          umount_chroot_env rootfs
          rm -f rootfs/setup-alpine.sh
          rm -f rootfs/etc/resolv.conf
        '


    - name: Create rootfs package
      id: create_rootfs_package
      run: |
        sudo -u root bash -c '
          cd project
          rootfs_filename="rootfs.tgz"
          tar cvzf ../artifact/${rootfs_filename} rootfs
          echo "##[set-output name=rootfs_filename;]$rootfs_filename"
        '

    - name: Upload rootfs package
      uses: svenstaro/upload-release-action@v2
      with:
        repo_token: ${{ secrets.GITHUB_TOKEN }}
        file: ./artifact/${{ steps.create_rootfs_package.outputs.rootfs_filename }}
        asset_name: ${{ steps.create_rootfs_package.outputs.rootfs_filename }}
        tag: ${{ needs.prepare_release.outputs.release_tag }}
        overwrite: true

  build_img:
    needs: [prepare_release,build_alpine]
    runs-on: ubuntu-22.04
    if: github.event.repository.owner.id == github.event.sender.id

    strategy:
      matrix:
        CPU: [rk3566]
    steps:
    - name: Checkout
      uses: actions/checkout@main

    - name: Initialization environment
      env:
        DEBIAN_FRONTEND: noninteractive
      run: |
        sudo rm -rf /etc/apt/sources.list.d
        wget https://raw.githubusercontent.com/friendlyarm/build-env-on-ubuntu-bionic/master/install.sh
        sed -i -e 's/^apt-get -y install openjdk-8-jdk/# apt-get -y install openjdk-8-jdk/g' install.sh
        sed -i -e 's/^\[ -d fa-toolchain \]/# [ -d fa-toolchain ]/g' install.sh
        sed -i -e 's/^(cat fa-toolchain/# (cat fa-toolchain/g' install.sh
        sed -i -e 's/^(tar xf fa-toolchain/# (tar xf fa-toolchain/g' install.sh
        sudo -E bash ./install.sh
        sudo -E git config --global user.name 'GitHub Actions'
        sudo -E git config --global user.email 'noreply@github.com'
        mkdir -p ./artifact
        sudo swapoff -a
        sudo rm -rf /usr/share/dotnet /usr/local/lib/android/sdk /usr/local/share/boost /opt/ghc
        echo "cores: $(nproc)"
        git clone https://github.com/friendlyarm/prebuilts.git -b master --depth 1
        cd prebuilts/gcc-x64
        sudo tar xf toolchain-11.3-aarch64.tar.xz -C /

    - name: Download alpine rootfs
      uses: robinraju/release-downloader@v1.6
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        repository: ${{ github.repository }}
        tag: ${{ needs.prepare_release.outputs.release_tag }}
        fileName: "rootfs.tgz"

    - name: Build sd image
      id: build_sd_image
      run: |
        mkdir project
        cd project
        case ${{ matrix.CPU }} in
        rk3328)
          BRANCH=kernel-6.6.y
          KERNEL_VARIANT=mainline
          ;;
        rk3528)
          BRANCH=kernel-6.1.y
          KERNEL_VARIANT=vendor
          ;;
        rk3399)
          BRANCH=kernel-6.6.y
          KERNEL_VARIANT=mainline
          ;;
        rk3568)
          BRANCH=kernel-6.1.y
          KERNEL_VARIANT=vendor
          ;;
        rk3566)
          BRANCH=kernel-6.1.y
          KERNEL_VARIANT=vendor
          ;;
        rk3576)
          BRANCH=kernel-6.1.y
          KERNEL_VARIANT=vendor
          ;;
        rk3588)
          BRANCH=kernel-6.1.y
          KERNEL_VARIANT=vendor
          ;;
        *)
          echo "unknow cpu"
          exit 1
          ;;
        esac

        git clone https://github.com/friendlyarm/sd-fuse_${{ matrix.CPU }} -b ${BRANCH} --depth=1 sd-fuse
        sudo su -c "tar xzfp "../rootfs.tgz" -C sd-fuse --numeric-owner --same-owner"
        if [ "${KERNEL_VARIANT}" = "mainline" ]; then
          sudo sed -i 's/ttyFIQ0/ttyS2/g' sd-fuse/rootfs/etc/inittab
        fi

        cd sd-fuse
        sudo -u root bash -c '
          OS_DIR=alpine-linux-arm64
          mkdir ${OS_DIR}

          cp prebuilt/parameter.template ${OS_DIR}/parameter.txt
          # Initialize the size, but it is not the final value, the build-rootfs-img.sh script will overwrite it
          sed -i "s/<ROOTFS_PARTITION_SIZE>/0x000c0000/g" ${OS_DIR}/parameter.txt
          sed -i "s/<USERDATA_PARTITION_ADDR>/0x00106000/g" ${OS_DIR}/parameter.txt

          if [ -f ../../plat/${{ matrix.CPU }}/custom.sh ]; then
            ../../plat/${{ matrix.CPU }}/custom.sh $PWD/rootfs
          fi
          cp -af ../../plat/rockchip-common/alsa/* $PWD/rootfs/

          # build uboot
          UBOOT_SRC=uboot ./build-uboot.sh ${OS_DIR}

          # build kernel
          DISABLE_MKIMG=1 KERNEL_SRC=kernel ./build-kernel.sh ${OS_DIR}
          TMP_DIR=$(mktemp -d out/boot.XXXXXXXXX)
          ./tools/setup_boot_and_rootfs.sh uboot kernel ${TMP_DIR} rootfs ./prebuilt ${OS_DIR}

          # add idbloader.img,boot.img, etc.
          ./tools/update_prebuilt.sh ./${OS_DIR} ./prebuilt

          # build rootfs.img
          ./build-rootfs-img.sh rootfs ${OS_DIR} 0 0
          echo "title=${OS_DIR}" > ./${OS_DIR}/info.conf
          echo "require-board=${{ matrix.CPU }}" >> ./${OS_DIR}/info.conf
          echo "version=$(date +%Y-%m-%d)" >> ./${OS_DIR}/info.conf

          # build sd image
          FILENAME_SD=${{ matrix.CPU }}-sd-alpine-linux-arm64-$(date +%Y-%m-%d).img
          echo "##[set-output name=img_filename_sd;]$FILENAME_SD"
          ./mk-sd-image.sh ${OS_DIR} ${FILENAME_SD}
          mv out/${FILENAME_SD} ../../artifact/

          # build sd-to-emmc image
          FILENAME_SD2EMMC=${{ matrix.CPU }}-eflasher-alpine-linux-arm64-$(date +%Y-%m-%d).img
          echo "##[set-output name=img_filename_sd2emmc;]$FILENAME_SD2EMMC"
          wget http://112.124.9.243/dvdfiles/${{ matrix.CPU }}/images-for-eflasher/emmc-flasher-images.tgz
          tar xzf emmc-flasher-images.tgz
          RAW_SIZE_MB=8000 ./mk-emmc-image.sh ${OS_DIR} filename=${FILENAME_SD2EMMC} autostart=yes
          mv out/${FILENAME_SD2EMMC} ../../artifact/

          # package image-assets-xyz.tgz
          IMAGE_ASSETS_PKG=image-assets-${{ matrix.CPU }}.tgz
          echo "##[set-output name=image_assets_pkg_filename;]$IMAGE_ASSETS_PKG"
          mkdir image-assets-${{ matrix.CPU }}
          tar cpzf image-assets-${{ matrix.CPU }}/rootfs.tgz rootfs
          mv ${OS_DIR} image-assets-${{ matrix.CPU }}/
          tar czf ${IMAGE_ASSETS_PKG} image-assets-${{ matrix.CPU }}
          mv ${IMAGE_ASSETS_PKG} ../../artifact/

          cd ../../artifact/
          gzip *.img
        '

    - name: Upload rootfs to release
      uses: svenstaro/upload-release-action@v2
      with:
        repo_token: ${{ secrets.GITHUB_TOKEN }}
        file: ./artifact/${{ steps.build_sd_image.outputs.image_assets_pkg_filename }}
        asset_name: ${{ steps.build_sd_image.outputs.image_assets_pkg_filename }}
        tag: ${{ needs.prepare_release.outputs.release_tag }}
        overwrite: true

    - name: Upload sd image to release
      uses: svenstaro/upload-release-action@v2
      with:
        repo_token: ${{ secrets.GITHUB_TOKEN }}
        file: ./artifact/${{ steps.build_sd_image.outputs.img_filename_sd }}.gz
        asset_name: ${{ steps.build_sd_image.outputs.img_filename_sd }}.gz
        tag: ${{ needs.prepare_release.outputs.release_tag }}
        overwrite: true

    - name: Upload sd-to-emmc image to release
      uses: svenstaro/upload-release-action@v2
      with:
        repo_token: ${{ secrets.GITHUB_TOKEN }}
        file: ./artifact/${{ steps.build_sd_image.outputs.img_filename_sd2emmc }}.gz
        asset_name: ${{ steps.build_sd_image.outputs.img_filename_sd2emmc }}.gz
        tag: ${{ needs.prepare_release.outputs.release_tag }}
        overwrite: true
