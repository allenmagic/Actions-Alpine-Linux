on:
  watch:
    types: started
jobs:
  prepare_release:
    runs-on: ubuntu-22.04
    if: github.event.repository.owner.id == github.event.sender.id
    steps:
    - name: Get release tag
      id: release_tag
      run: |
        release_tag="alpine-$(date +%Y-%m-%d)"
        echo "##[set-output name=release_tag;]$release_tag"

    - name: Create empty release
      id: release
      uses: softprops/action-gh-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ steps.release_tag.outputs.release_tag }}
        draft: false
        prerelease: false
    outputs:
      release_tag: ${{ steps.release_tag.outputs.release_tag }}
      upload_url: ${{ steps.release.outputs.upload_url }}

  build_alpine:
    needs: prepare_release
    runs-on: ubuntu-22.04
    if: github.event.repository.owner.id == github.event.sender.id
    steps:
    - name: Checkout
      uses: actions/checkout@main

    - name: Initialization environment
      env:
        DEBIAN_FRONTEND: noninteractive
      run: |
        sudo rm -rf /etc/apt/sources.list.d
        wget https://raw.githubusercontent.com/friendlyarm/build-env-on-ubuntu-bionic/master/install.sh
        sed -i -e 's/^apt-get -y install openjdk-8-jdk/# apt-get -y install openjdk-8-jdk/g' install.sh
        sed -i -e 's/^\[ -d fa-toolchain \]/# [ -d fa-toolchain ]/g' install.sh
        sed -i -e 's/^(cat fa-toolchain/# (cat fa-toolchain/g' install.sh
        sed -i -e 's/^(tar xf fa-toolchain/# (tar xf fa-toolchain/g' install.sh
        sudo -E bash ./install.sh
        sudo -E git config --global user.name 'GitHub Actions'
        sudo -E git config --global user.email 'noreply@github.com'
        mkdir -p ./artifact
        sudo swapoff -a
        sudo rm -rf /usr/share/dotnet /usr/local/lib/android/sdk /usr/local/share/boost /opt/ghc
        echo "cores: $(nproc)"

    - name: Download alpine-minirootfs
      run: |
        mkdir project
        cd project
        wget https://dl-cdn.alpinelinux.org/alpine/v3.23/releases/aarch64/alpine-minirootfs-3.23.2-aarch64.tar.gz
        mkdir rootfs
        sudo -E tar xzfp alpine-minirootfs-3.23.2-aarch64.tar.gz --numeric-owner --same-owner -C rootfs

name: Customize and Validate Services
on: [push, pull_request]

jobs:
  build-and-validate:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Apply customizations and validate services
        run: |
          sudo -u root bash -c '
            # 确保project目录存在（根据实际项目结构调整，若已存在可跳过）
            mkdir -p project
            cd project

            # 1. 基础环境准备
            cp /etc/resolv.conf rootfs/etc/resolv.conf 2>/dev/null || true
            mkdir -p rootfs/etc/dnsmasq.d
            mkdir -p rootfs/etc/nftables.d
            mkdir -p rootfs/usr/local/bin
            mkdir -p rootfs/etc/profile.d
            mkdir -p rootfs/etc/local.d

            # 核心安全操作：在宿主机层面直接为 rootfs 注入必要工具
            LANG=C chroot rootfs /bin/sh -c "apk update && apk add --no-cache bash nftables dnsmasq file" 2>/dev/null || true
            
            # 2. 注入自定义脚本 (确保路径 ../scripts/ 正确，若脚本不存在可先创建空目录)
            mkdir -p ../scripts/bin ../scripts/config
            cp -rv ../scripts/bin/* rootfs/usr/local/bin/ 2>/dev/null || true
            chmod +x rootfs/usr/local/bin/* 2>/dev/null || true
            
            # 注入welcome脚本
            touch ../scripts/welcome.sh
            cp ../scripts/welcome.sh rootfs/etc/profile.d/ 2>/dev/null || true
            chmod +x rootfs/etc/profile.d/welcome.sh 2>/dev/null || true
        
            # 2.1 将 repo 的 config 目录下所有内容同步到 rootfs/etc/
            if [ -d "../config" ]; then
              cp -rv ../config/* rootfs/etc/ 2>/dev/null || true
            fi
            # 将local.d目录下的start文件授权为可执行文件
            chmod +x rootfs/etc/local.d/*.start 2>/dev/null || true
            
            # 3. 注入安装主脚本
            touch ../scripts/setup-alpine.sh
            cp ../scripts/setup-alpine.sh rootfs/ 2>/dev/null || true
            chmod +x rootfs/setup-alpine.sh 2>/dev/null || true
            
            # 4. 加载chroot环境配置（确保set_chroot_env.sh存在，若不存在可简化挂载）
            if [ -f "../scripts/set_chroot_env.sh" ]; then
              source ../scripts/set_chroot_env.sh
              mount_chroot_env rootfs 2>/dev/null || true
            else
              # 简易挂载（若无专用脚本，提供基础挂载逻辑）
              mount -t proc proc rootfs/proc/ 2>/dev/null || true
              mount -t sysfs sys rootfs/sys/ 2>/dev/null || true
              mount -o bind /dev rootfs/dev/ 2>/dev/null || true
              mount -o bind /dev/pts rootfs/dev/pts/ 2>/dev/null || true
            fi
            
            # 执行 setup-alpine.sh
            LANG=C chroot rootfs /bin/bash /setup-alpine.sh 2>/dev/null || true
            
            # ===================== 通用配置校验函数（使用rootfs内工具）=====================
            check_config_with_rootfs_tool() {
              local service_name=$1          # 服务名（dnsmasq/nftables）
              local check_cmd=$2             # 校验命令模板
              local config_files=("${@:3}")  # 配置文件列表（rootfs内绝对路径）
              
              echo -e "\n========== 开始校验 ${service_name} 配置语法（使用rootfs内工具）=========="
              local error_flag=0
              
              for config in "${config_files[@]}"; do
                # 检查配置文件是否存在（在rootfs内判断）
                if ! chroot rootfs /bin/bash -c "test -f \"${config}\"" 2>/dev/null; then
                  echo "ℹ️ 配置文件 ${config} 不存在，跳过校验"
                  continue
                fi
                
                # 执行语法校验，捕获完整日志
                echo "正在校验配置文件：${config}"
                local check_log
                check_log=$(chroot rootfs /bin/bash -c "${check_cmd} \"${config}\"" 2>&1)
                local exit_code=$?
                
                # 判断校验结果
                if [ ${exit_code} -ne 0 ]; then
                  echo -e "❌ ${service_name} 配置文件 ${config} 语法错误！"
                  echo -e "报错详情：\n${check_log}"
                  error_flag=1
                  break
                fi
                echo "✅ ${config} 语法校验通过"
              done
              
              if [ ${error_flag} -eq 1 ]; then
                echo -e "\n========== ${service_name} 配置校验失败，终止构建 =========="
                return 1
              fi
              echo -e "\n========== ${service_name} 所有配置语法校验通过 =========="
              return 0
            }
            
            # ===================== 1. DNSMasq 配置语法校验（rootfs内工具）=====================
            # 定义dnsmasq配置文件列表（根据实际路径调整，可添加/删除）
            dnsmasq_configs=(
              "/etc/dnsmasq.conf"
              "/etc/dnsmasq.d/custom1.conf"
              "/etc/dnsmasq.d/custom2.conf"
              "/etc/dnsmasq.d/*.conf"
            )
            if ! check_config_with_rootfs_tool "dnsmasq" "dnsmasq --test -C" "${dnsmasq_configs[@]}"; then
              # 清理挂载环境
              if [ -f "../scripts/set_chroot_env.sh" ]; then
                umount_chroot_env rootfs 2>/dev/null || true
              else
                umount rootfs/dev/pts/ 2>/dev/null || true
                umount rootfs/dev/ 2>/dev/null || true
                umount rootfs/sys/ 2>/dev/null || true
                umount rootfs/proc/ 2>/dev/null || true
              fi
              exit 1
            fi
            
            # ===================== 2. NFTables 配置语法校验（rootfs内工具）=====================
            # 定义nftables配置文件列表（按依赖顺序排列，先变量后规则）
            nft_configs=(
              "/etc/nftables.d/00-vars.nft"
              "/etc/nftables.d/01-input.nft"
              "/etc/nftables.d/02-output.nft"
              "/etc/nftables.d/*.nft"
              "/etc/nftables.conf"
            )
            if ! check_config_with_rootfs_tool "nftables" "nft -c -f" "${nft_configs[@]}"; then
              # 清理挂载环境
              if [ -f "../scripts/set_chroot_env.sh" ]; then
                umount_chroot_env rootfs 2>/dev/null || true
              else
                umount rootfs/dev/pts/ 2>/dev/null || true
                umount rootfs/dev/ 2>/dev/null || true
                umount rootfs/sys/ 2>/dev/null || true
                umount rootfs/proc/ 2>/dev/null || true
              fi
              exit 1
            fi
            
            # ===================== 3. NFTables 服务状态检查 =====================
            check_nftables_service() {
              echo -e "\n========== 开始执行 nftables 服务状态检查 =========="
              
              # 检查rootfs内nftables服务脚本是否存在
              if ! chroot rootfs /bin/bash -c "test -f /etc/init.d/nftables" 2>/dev/null; then
                echo "❌ rootfs内无nftables服务脚本，服务无法启动"
                return 1
              fi
              echo "✅ rootfs内nftables服务脚本存在"

              # 查询当前服务状态，避免重复启动
              local pre_status_log
              pre_status_log=$(LANG=C chroot rootfs /bin/bash -c "rc-service nftables status" 2>&1)
              
              if echo "$pre_status_log" | grep -qiE "running|started|already starting"; then
                echo "ℹ️ nftables服务已处于运行中/启动中状态，无需重复启动"
              else
                echo "ℹ️ nftables服务未运行，尝试启动服务（验证服务脚本有效性）..."
                local nft_start_log
                nft_start_log=$(LANG=C chroot rootfs /bin/bash -c "rc-service nftables start" 2>&1)
                local start_exit_code=$?
                
                # 过滤允许的警告（内核不支持等环境问题，非脚本错误）
                local allowed_warnings=("already starting|already running|Netlink socket|Protocol not supported")
                if [ $start_exit_code -ne 0 ] && ! echo "$nft_start_log" | grep -qiE "${allowed_warnings}"; then
                  echo "❌ nftables服务启动脚本执行失败！"
                  echo "启动日志详情：\n${nft_start_log}"
                  return 1
                fi
                echo "✅ nftables服务启动脚本执行成功（或忽略内核不支持警告）"
              fi

              # 最终验证服务脚本状态（忽略内核相关异常）
              local nft_status_log
              nft_status_log=$(LANG=C chroot rootfs /bin/bash -c "rc-service nftables status" 2>&1)
              
              if echo "$nft_status_log" | grep -qiE "stopped|not running|inactive|dead" && \
                 ! echo "$nft_status_log" | grep -qiE "Netlink socket|Protocol not supported"; then
                echo "❌ nftables服务未处于正常运行状态（非内核原因）！"
                echo "状态查询日志详情：\n${nft_status_log}"
                return 1
              fi
              echo "✅ nftables服务脚本状态正常（忽略内核不支持相关异常）"
              echo -e "\n========== nftables 服务状态检查通过 =========="
              return 0
            }
            
            # 执行nftables服务检查
            if ! check_nftables_service; then
              # 清理挂载环境
              if [ -f "../scripts/set_chroot_env.sh" ]; then
                umount_chroot_env rootfs 2>/dev/null || true
              else
                umount rootfs/dev/pts/ 2>/dev/null || true
                umount rootfs/dev/ 2>/dev/null || true
                umount rootfs/sys/ 2>/dev/null || true
                umount rootfs/proc/ 2>/dev/null || true
              fi
              echo "构建终止：nftables 服务检查未通过"
              exit 1
            fi
            
            # ===================== 4. DNSMasq 服务状态检查 =====================
            check_dnsmasq_service() {
              echo -e "\n========== 开始执行 dnsmasq 服务状态检查 =========="
              
              # 检查rootfs内dnsmasq命令是否可用
              if ! LANG=C chroot rootfs /bin/bash -c "command -v dnsmasq >/dev/null 2>&1"; then
                echo "❌ rootfs内未安装dnsmasq，命令不可用"
                return 1
              fi
              echo "✅ rootfs内dnsmasq命令可用"

              # 检查dnsmasq服务脚本是否存在
              if ! chroot rootfs /bin/bash -c "test -f /etc/init.d/dnsmasq" 2>/dev/null; then
                echo "❌ rootfs内无dnsmasq服务脚本，服务无法启动"
                return 1
              fi
              echo "✅ rootfs内dnsmasq服务脚本存在"

              # 查询当前服务状态，避免重复启动
              local dns_pre_status_log
              dns_pre_status_log=$(LANG=C chroot rootfs /bin/bash -c "rc-service dnsmasq status" 2>&1)
              
              if echo "$dns_pre_status_log" | grep -qiE "running|started|already starting"; then
                echo "ℹ️ dnsmasq服务已处于运行中/启动中状态，无需重复启动"
              else
                echo "ℹ️ dnsmasq服务未运行，尝试启动服务..."
                local dns_start_log
                dns_start_log=$(LANG=C chroot rootfs /bin/bash -c "rc-service dnsmasq start" 2>&1)
                local dns_start_exit=$?
                
                # 过滤允许的警告
                local dns_allowed_warnings=("already starting|already running")
                if [ $dns_start_exit -ne 0 ] && ! echo "$dns_start_log" | grep -qiE "${dns_allowed_warnings}"; then
                  echo "❌ dnsmasq服务启动失败！"
                  echo "启动日志详情：\n${dns_start_log}"
                  return 1
                fi
                echo "✅ dnsmasq服务启动命令执行成功（或已提前启动）"
              fi

              # 最终验证服务运行状态
              local dns_status_log
              dns_status_log=$(LANG=C chroot rootfs /bin/bash -c "rc-service dnsmasq status" 2>&1)
              local dns_status_exit=$?
              
              if [ $dns_status_exit -ne 0 ] && echo "$dns_status_log" | grep -qiE "stopped|not running|inactive|dead"; then
                echo "❌ dnsmasq服务启动后未处于运行状态！"
                echo "状态查询日志详情：\n${dns_status_log}"
                return 1
              fi
              echo "✅ dnsmasq服务已处于正常运行状态"
              echo -e "\n========== dnsmasq 服务状态检查通过 =========="
              return 0
            }
            
            # 执行dnsmasq服务检查
            if ! check_dnsmasq_service; then
              # 清理挂载环境
              if [ -f "../scripts/set_chroot_env.sh" ]; then
                umount_chroot_env rootfs 2>/dev/null || true
              else
                umount rootfs/dev/pts/ 2>/dev/null || true
                umount rootfs/dev/ 2>/dev/null || true
                umount rootfs/sys/ 2>/dev/null || true
                umount rootfs/proc/ 2>/dev/null || true
              fi
              echo "构建终止：dnsmasq 服务检查未通过"
              exit 1
            fi
            
            # ===================== 5. 额外加固：创建 ppp.wan 符号链接 =====================
            if [ -e rootfs/etc/init.d/ppp ]; then
              ln -sf ppp rootfs/etc/init.d/ppp.wan 2>/dev/null || true
              echo "✅ 成功创建 ppp.wan 符号链接"
            else
              echo "ℹ️ 未找到 /etc/init.d/ppp，跳过 ppp.wan 符号链接创建"
            fi

            # 检测自定义效果
            echo -e "\n========== 检测nftables自定义配置效果 =========="
            cat rootfs/etc/nftables.d/00-vars.nft 2>/dev/null || echo "ℹ️ nftables 00-vars.nft 配置文件不存在"
            
            # ===================== 6. 环境清理 =====================
            echo -e "\n========== 开始清理环境 =========="
            # 停止服务（可选，按需执行）
            LANG=C chroot rootfs /bin/bash -c "rc-service dnsmasq stop" 2>/dev/null || true
            LANG=C chroot rootfs /bin/bash -c "rc-service nftables stop" 2>/dev/null || true
            
            # 卸载chroot挂载
            if [ -f "../scripts/set_chroot_env.sh" ]; then
              umount_chroot_env rootfs 2>/dev/null || true
            else
              umount rootfs/dev/pts/ 2>/dev/null || true
              umount rootfs/dev/ 2>/dev/null || true
              umount rootfs/sys/ 2>/dev/null || true
              umount rootfs/proc/ 2>/dev/null || true
            fi
            
            # 删除临时文件
            rm -f rootfs/setup-alpine.sh 2>/dev/null || true
            rm -f rootfs/etc/resolv.conf 2>/dev/null || true
            
            echo -e "\n✅ 所有操作完成，构建和校验成功！"
          '

    - name: Create rootfs package
      id: create_rootfs_package
      run: |
        sudo -u root bash -c '
          cd project
          rootfs_filename="rootfs.tgz"
          tar cvzf ../artifact/${rootfs_filename} rootfs
          echo "##[set-output name=rootfs_filename;]$rootfs_filename"
        '

    - name: Upload rootfs package
      uses: svenstaro/upload-release-action@v2
      with:
        repo_token: ${{ secrets.GITHUB_TOKEN }}
        file: ./artifact/${{ steps.create_rootfs_package.outputs.rootfs_filename }}
        asset_name: ${{ steps.create_rootfs_package.outputs.rootfs_filename }}
        tag: ${{ needs.prepare_release.outputs.release_tag }}
        overwrite: true

  build_img:
    needs: [prepare_release,build_alpine]
    runs-on: ubuntu-22.04
    if: github.event.repository.owner.id == github.event.sender.id

    strategy:
      matrix:
        CPU: [rk3566]
    steps:
    - name: Checkout
      uses: actions/checkout@main

    - name: Initialization environment
      env:
        DEBIAN_FRONTEND: noninteractive
      run: |
        sudo rm -rf /etc/apt/sources.list.d
        wget https://raw.githubusercontent.com/friendlyarm/build-env-on-ubuntu-bionic/master/install.sh
        sed -i -e 's/^apt-get -y install openjdk-8-jdk/# apt-get -y install openjdk-8-jdk/g' install.sh
        sed -i -e 's/^\[ -d fa-toolchain \]/# [ -d fa-toolchain ]/g' install.sh
        sed -i -e 's/^(cat fa-toolchain/# (cat fa-toolchain/g' install.sh
        sed -i -e 's/^(tar xf fa-toolchain/# (tar xf fa-toolchain/g' install.sh
        sudo -E bash ./install.sh
        sudo -E git config --global user.name 'GitHub Actions'
        sudo -E git config --global user.email 'noreply@github.com'
        mkdir -p ./artifact
        sudo swapoff -a
        sudo rm -rf /usr/share/dotnet /usr/local/lib/android/sdk /usr/local/share/boost /opt/ghc
        echo "cores: $(nproc)"
        git clone https://github.com/friendlyarm/prebuilts.git -b master --depth 1
        cd prebuilts/gcc-x64
        sudo tar xf toolchain-11.3-aarch64.tar.xz -C /

    - name: Download alpine rootfs
      uses: robinraju/release-downloader@v1.6
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        repository: ${{ github.repository }}
        tag: ${{ needs.prepare_release.outputs.release_tag }}
        fileName: "rootfs.tgz"

    - name: Build sd image
      id: build_sd_image
      run: |
        mkdir project
        cd project
        case ${{ matrix.CPU }} in
        rk3328)
          BRANCH=kernel-6.6.y
          KERNEL_VARIANT=mainline
          ;;
        rk3528)
          BRANCH=kernel-6.1.y
          KERNEL_VARIANT=vendor
          ;;
        rk3399)
          BRANCH=kernel-6.6.y
          KERNEL_VARIANT=mainline
          ;;
        rk3568)
          BRANCH=kernel-6.1.y
          KERNEL_VARIANT=vendor
          ;;
        rk3566)
          BRANCH=kernel-6.1.y
          KERNEL_VARIANT=vendor
          ;;
        rk3576)
          BRANCH=kernel-6.1.y
          KERNEL_VARIANT=vendor
          ;;
        rk3588)
          BRANCH=kernel-6.1.y
          KERNEL_VARIANT=vendor
          ;;
        *)
          echo "unknow cpu"
          exit 1
          ;;
        esac

        git clone https://github.com/friendlyarm/sd-fuse_${{ matrix.CPU }} -b ${BRANCH} --depth=1 sd-fuse
        sudo su -c "tar xzfp "../rootfs.tgz" -C sd-fuse --numeric-owner --same-owner"
        if [ "${KERNEL_VARIANT}" = "mainline" ]; then
          sudo sed -i 's/ttyFIQ0/ttyS2/g' sd-fuse/rootfs/etc/inittab
        fi

        cd sd-fuse
        sudo -u root bash -c '
          OS_DIR=alpine-linux-arm64
          mkdir ${OS_DIR}

          cp prebuilt/parameter.template ${OS_DIR}/parameter.txt
          # Initialize the size, but it is not the final value, the build-rootfs-img.sh script will overwrite it
          sed -i "s/<ROOTFS_PARTITION_SIZE>/0x000c0000/g" ${OS_DIR}/parameter.txt
          sed -i "s/<USERDATA_PARTITION_ADDR>/0x00106000/g" ${OS_DIR}/parameter.txt

          if [ -f ../../plat/${{ matrix.CPU }}/custom.sh ]; then
            ../../plat/${{ matrix.CPU }}/custom.sh $PWD/rootfs
          fi
          cp -af ../../plat/rockchip-common/alsa/* $PWD/rootfs/

          # build uboot
          UBOOT_SRC=uboot ./build-uboot.sh ${OS_DIR}

          # build kernel
          DISABLE_MKIMG=1 KERNEL_SRC=kernel ./build-kernel.sh ${OS_DIR}
          TMP_DIR=$(mktemp -d out/boot.XXXXXXXXX)
          ./tools/setup_boot_and_rootfs.sh uboot kernel ${TMP_DIR} rootfs ./prebuilt ${OS_DIR}

          # add idbloader.img,boot.img, etc.
          ./tools/update_prebuilt.sh ./${OS_DIR} ./prebuilt

          # build rootfs.img
          ./build-rootfs-img.sh rootfs ${OS_DIR} 0 0
          echo "title=${OS_DIR}" > ./${OS_DIR}/info.conf
          echo "require-board=${{ matrix.CPU }}" >> ./${OS_DIR}/info.conf
          echo "version=$(date +%Y-%m-%d)" >> ./${OS_DIR}/info.conf

          # build sd image
          FILENAME_SD=${{ matrix.CPU }}-sd-alpine-linux-arm64-$(date +%Y-%m-%d).img
          echo "##[set-output name=img_filename_sd;]$FILENAME_SD"
          ./mk-sd-image.sh ${OS_DIR} ${FILENAME_SD}
          mv out/${FILENAME_SD} ../../artifact/

          # build sd-to-emmc image
          FILENAME_SD2EMMC=${{ matrix.CPU }}-eflasher-alpine-linux-arm64-$(date +%Y-%m-%d).img
          echo "##[set-output name=img_filename_sd2emmc;]$FILENAME_SD2EMMC"
          wget http://112.124.9.243/dvdfiles/${{ matrix.CPU }}/images-for-eflasher/emmc-flasher-images.tgz
          tar xzf emmc-flasher-images.tgz
          RAW_SIZE_MB=8000 ./mk-emmc-image.sh ${OS_DIR} filename=${FILENAME_SD2EMMC} autostart=yes
          mv out/${FILENAME_SD2EMMC} ../../artifact/

          # package image-assets-xyz.tgz
          IMAGE_ASSETS_PKG=image-assets-${{ matrix.CPU }}.tgz
          echo "##[set-output name=image_assets_pkg_filename;]$IMAGE_ASSETS_PKG"
          mkdir image-assets-${{ matrix.CPU }}
          tar cpzf image-assets-${{ matrix.CPU }}/rootfs.tgz rootfs
          mv ${OS_DIR} image-assets-${{ matrix.CPU }}/
          tar czf ${IMAGE_ASSETS_PKG} image-assets-${{ matrix.CPU }}
          mv ${IMAGE_ASSETS_PKG} ../../artifact/

          cd ../../artifact/
          gzip *.img
        '

    - name: Upload rootfs to release
      uses: svenstaro/upload-release-action@v2
      with:
        repo_token: ${{ secrets.GITHUB_TOKEN }}
        file: ./artifact/${{ steps.build_sd_image.outputs.image_assets_pkg_filename }}
        asset_name: ${{ steps.build_sd_image.outputs.image_assets_pkg_filename }}
        tag: ${{ needs.prepare_release.outputs.release_tag }}
        overwrite: true

    - name: Upload sd image to release
      uses: svenstaro/upload-release-action@v2
      with:
        repo_token: ${{ secrets.GITHUB_TOKEN }}
        file: ./artifact/${{ steps.build_sd_image.outputs.img_filename_sd }}.gz
        asset_name: ${{ steps.build_sd_image.outputs.img_filename_sd }}.gz
        tag: ${{ needs.prepare_release.outputs.release_tag }}
        overwrite: true

    - name: Upload sd-to-emmc image to release
      uses: svenstaro/upload-release-action@v2
      with:
        repo_token: ${{ secrets.GITHUB_TOKEN }}
        file: ./artifact/${{ steps.build_sd_image.outputs.img_filename_sd2emmc }}.gz
        asset_name: ${{ steps.build_sd_image.outputs.img_filename_sd2emmc }}.gz
        tag: ${{ needs.prepare_release.outputs.release_tag }}
        overwrite: true
