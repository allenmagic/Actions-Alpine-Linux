on:
  watch:
    types: started
jobs:
  prepare_release:
    runs-on: ubuntu-22.04
    if: github.event.repository.owner.id == github.event.sender.id
    steps:
    - name: Get release tag
      id: release_tag
      run: |
        release_tag="alpine-$(date +%Y-%m-%d)"
        echo "##[set-output name=release_tag;]$release_tag"

    - name: Create empty release
      id: release
      uses: softprops/action-gh-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ steps.release_tag.outputs.release_tag }}
        draft: false
        prerelease: false
    outputs:
      release_tag: ${{ steps.release_tag.outputs.release_tag }}
      upload_url: ${{ steps.release.outputs.upload_url }}

  build_alpine:
    needs: prepare_release
    runs-on: ubuntu-22.04
    if: github.event.repository.owner.id == github.event.sender.id
    steps:
    - name: Checkout
      uses: actions/checkout@main

    - name: Initialization environment
      env:
        DEBIAN_FRONTEND: noninteractive
      run: |
        sudo rm -rf /etc/apt/sources.list.d
        wget https://raw.githubusercontent.com/friendlyarm/build-env-on-ubuntu-bionic/master/install.sh
        sed -i -e 's/^apt-get -y install openjdk-8-jdk/# apt-get -y install openjdk-8-jdk/g' install.sh
        sed -i -e 's/^\[ -d fa-toolchain \]/# [ -d fa-toolchain ]/g' install.sh
        sed -i -e 's/^(cat fa-toolchain/# (cat fa-toolchain/g' install.sh
        sed -i -e 's/^(tar xf fa-toolchain/# (tar xf fa-toolchain/g' install.sh
        sudo -E bash ./install.sh
        sudo -E git config --global user.name 'GitHub Actions'
        sudo -E git config --global user.email 'noreply@github.com'
        mkdir -p ./artifact
        sudo swapoff -a
        sudo rm -rf /usr/share/dotnet /usr/local/lib/android/sdk /usr/local/share/boost /opt/ghc
        echo "cores: $(nproc)"

    - name: Download alpine-minirootfs
      run: |
        mkdir project
        cd project
        wget https://dl-cdn.alpinelinux.org/alpine/v3.23/releases/aarch64/alpine-minirootfs-3.23.2-aarch64.tar.gz
        mkdir rootfs
        sudo -E tar xzfp alpine-minirootfs-3.23.2-aarch64.tar.gz --numeric-owner --same-owner -C rootfs

    - name: Apply customizations and service checks
      run: |
        sudo -u root bash -c '
          cd project
          # 1. 基础环境准备
          cp /etc/resolv.conf rootfs/etc/resolv.conf
          mkdir -p rootfs/etc/dnsmasq.d
          mkdir -p rootfs/etc/nftables.d

          # 核心安全操作：在宿主机层面直接为 rootfs 注入 bash
          LANG=C chroot rootfs /bin/sh -c "apk update && apk add --no-cache bash nftables dnsmasq file"
          
          # 2. 注入自定义脚本 (确保路径 ../scripts/ 正确)
          cp -rv ../scripts/bin/* rootfs/usr/local/bin/
          chmod +x rootfs/usr/local/bin/*
          # 注入welcome脚本
          cp ../scripts/welcome.sh rootfs/etc/profile.d/
          chmod +x rootfs/etc/profile.d/welcome.sh
        
          # 2.1 将 repo 的 config 目录下所有内容同步到 rootfs/etc/
          if [ -d "../config" ]; then
            cp -rv ../scripts/../config/* rootfs/etc/
          fi
          # 将local.d目录下的start文件授权为可执行文件
          chmod +x rootfs/etc/local.d/*.start 2>/dev/null || true
          
          # 3. 注入安装主脚本
          cp ../scripts/setup-alpine.sh rootfs/
          
          # 4. 进入 chroot 执行安装
          source ../scripts/set_chroot_env.sh
          mount_chroot_env rootfs
          
          # 执行 setup-alpine.sh
          LANG=C chroot rootfs /bin/bash /setup-alpine.sh
          
          # ===================== dnsmasq 配置文件前置校验 =====================
          check_dnsmasq_config_files() {
            echo "========== 开始校验 dnsmasq.d 目录下的配置文件 =========="
            local conf_dir="rootfs/etc/dnsmasq.d"
            
            # 检查目录是否存在
            if [ ! -d "$conf_dir" ]; then
              echo "✅ dnsmasq.d 目录不存在，跳过配置文件校验"
              return 0
            fi
            
            # 遍历所有.conf文件（兼容目录为空的情况）
            shopt -s nullglob
            local conf_files=("${conf_dir}"/*.conf)
            shopt -u nullglob
            
            if [ ${#conf_files[@]} -eq 0 ]; then
              echo "✅ dnsmasq.d 目录下无.conf配置文件，跳过校验"
              return 0
            fi
            
            # 逐个校验配置文件
            for file in "${conf_files[@]}"; do
              echo -e "\n正在校验文件：$file"
              
              # 检查文件是否为普通文本文件
              if ! file "$file" | grep -qi "text"; then
                echo "❌ 错误：$file 不是普通文本文件，可能导致dnsmasq启动失败"
                return 1
              fi
              echo "✅ 文件类型校验通过（普通文本文件）"
              
              # 检查文件权限（确保dnsmasq可读取）
              if [ ! -r "$file" ]; then
                echo "❌ 错误：$file 权限不足，dnsmasq无法读取该配置文件"
                return 1
              fi
              echo "✅ 文件权限校验通过（具备可读权限）"
              
              # 非空文件执行语法校验
              if [ -s "$file" ]; then
                local syntax_check
                syntax_check=$(LANG=C chroot rootfs /bin/bash -c "dnsmasq --test -C /etc/dnsmasq.d/$(basename "$file")" 2>&1)
                local syntax_exit=$?
                if [ $syntax_exit -ne 0 ]; then
                  echo "❌ 错误：$file 配置语法有误！"
                  echo "语法校验日志：$syntax_check"
                  return 1
                fi
                echo "✅ 配置语法校验通过（非空文件有效）"
              else
                echo "✅ 文件为空，dnsmasq会自动忽略，无需语法校验"
              fi
            done
            
            echo -e "\n========== dnsmasq.d 目录下所有配置文件校验通过 =========="
            return 0
          }
          
          # 执行dnsmasq配置文件校验，失败则终止构建
          if ! check_dnsmasq_config_files; then
            echo "构建终止：dnsmasq 配置文件校验未通过"
            umount_chroot_env rootfs
            exit 1
          fi
          
          # ===================== nftables 完整检查逻辑（修复版） =====================
          # 定义nftables专用检查函数（优化状态判断，忽略已启动警告）
          check_nftables() {
            echo "========== 开始执行 nftables 完整性检查 =========="
            
            # 检查1：验证nftables命令是否可用（基础依赖检查）
            echo "1. 检查nftables命令是否存在..."
            if ! LANG=C chroot rootfs /bin/bash -c "command -v nft >/dev/null 2>&1"; then
              echo "❌ 错误：nftables未安装，nft命令不可用"
              return 1
            fi
            echo "✅ nftables命令可用"

            # 检查2：先查询nftables当前状态，避免重复启动
            echo -e "\n2. 查询nftables当前服务状态..."
            local pre_status_log
            pre_status_log=$(LANG=C chroot rootfs /bin/bash -c "rc-service nftables status" 2>&1)
            local pre_status_exit=$?
            
            # 判断当前状态：已运行/启动中 或 未运行
            if echo "$pre_status_log" | grep -qiE "running|started|already starting"; then
              echo "ℹ️ nftables服务已处于运行中/启动中状态，无需重复启动"
              local service_already_running=1
            else
              echo "ℹ️ nftables服务未运行，尝试启动服务..."
              local service_already_running=0
              
              # 尝试启动服务，捕获启动输出和退出码
              local nft_start_log
              nft_start_log=$(LANG=C chroot rootfs /bin/bash -c "rc-service nftables start" 2>&1)
              local start_exit_code=$?
              
              # 过滤允许的警告，仅判断真正的错误
              local allowed_warnings=("already starting|already running")
              if [ $start_exit_code -ne 0 ] && ! echo "$nft_start_log" | grep -qiE "${allowed_warnings}"; then
                echo "❌ nftables服务启动失败！"
                echo "启动日志详情："
                echo "$nft_start_log"
                return 1
              fi
              echo "✅ nftables服务启动命令执行成功（或已提前启动）"
            fi

            # 检查3：最终验证nftables服务是否处于运行状态
            echo -e "\n3. 最终验证nftables服务运行状态..."
            local nft_status_log
            nft_status_log=$(LANG=C chroot rootfs /bin/bash -c "rc-service nftables status" 2>&1)
            local status_exit_code=$?
            
            # 仅匹配真正的异常状态，忽略警告
            if [ $status_exit_code -ne 0 ] && echo "$nft_status_log" | grep -qiE "stopped|not running|inactive|dead"; then
              echo "❌ nftables服务未处于正常运行状态！"
              echo "状态查询日志详情："
              echo "$nft_status_log"
              return 1
            fi
            echo "✅ nftables服务已处于正常运行状态"

            # 检查4：验证nftables规则是否成功加载（关键验证）
            echo -e "\n4. 验证nftables防火墙规则是否加载..."
            local nft_rules_log
            nft_rules_log=$(LANG=C chroot rootfs /bin/bash -c "nft list ruleset" 2>&1)
            local rules_exit_code=$?
            
            # 规则加载判断：退出码非0 或 规则为空（仅含注释/空行）
            if [ $rules_exit_code -ne 0 ]; then
              echo "❌ nftables规则查询失败！"
              echo "规则查询日志详情："
              echo "$nft_rules_log"
              return 1
            fi
            
            # 过滤空行和注释，判断是否有实际规则
            local actual_rules
            actual_rules=$(echo "$nft_rules_log" | grep -vE "^#|^$|^ *$")
            if [ -z "$actual_rules" ]; then
              echo "❌ nftables服务启动成功，但未加载任何实际防火墙规则！"
              return 1
            fi
            echo "✅ nftables防火墙规则已成功加载，规则详情如下："
            echo "$nft_rules_log"

            echo -e "\n========== nftables 所有检查项均通过 =========="
            return 0
          }
          
          # 执行nftables检查，失败则终止构建
          if ! check_nftables; then
            echo "构建终止：nftables 检查未通过（服务无法启动或规则未加载）"
            umount_chroot_env rootfs
            exit 1
          fi
          
          # ===================== dnsmasq 服务启动检查 =====================
          check_dnsmasq_service() {
            echo "========== 开始执行 dnsmasq 服务完整性检查 =========="
            
            # 检查1：验证dnsmasq命令是否可用
            echo "1. 检查dnsmasq命令是否存在..."
            if ! LANG=C chroot rootfs /bin/bash -c "command -v dnsmasq >/dev/null 2>&1"; then
              echo "❌ 错误：dnsmasq未安装，命令不可用"
              return 1
            fi
            echo "✅ dnsmasq命令可用"

            # 检查2：先查询dnsmasq当前状态，避免重复启动
            echo -e "\n2. 查询dnsmasq当前服务状态..."
            local dns_pre_status_log
            dns_pre_status_log=$(LANG=C chroot rootfs /bin/bash -c "rc-service dnsmasq status" 2>&1)
            
            if echo "$dns_pre_status_log" | grep -qiE "running|started|already starting"; then
              echo "ℹ️ dnsmasq服务已处于运行中/启动中状态，无需重复启动"
            else
              echo "ℹ️ dnsmasq服务未运行，尝试启动服务..."
              local dns_start_log
              dns_start_log=$(LANG=C chroot rootfs /bin/bash -c "rc-service dnsmasq start" 2>&1)
              local dns_start_exit=$?
              
              # 过滤允许的警告，判断真正的错误
              local dns_allowed_warnings=("already starting|already running")
              if [ $dns_start_exit -ne 0 ] && ! echo "$dns_start_log" | grep -qiE "${dns_allowed_warnings}"; then
                echo "❌ dnsmasq服务启动失败！"
                echo "启动日志详情："
                echo "$dns_start_log"
                return 1
              fi
              echo "✅ dnsmasq服务启动命令执行成功（或已提前启动）"
            fi

            # 检查3：验证dnsmasq服务运行状态
            echo -e "\n3. 验证dnsmasq服务运行状态..."
            local dns_status_log
            dns_status_log=$(LANG=C chroot rootfs /bin/bash -c "rc-service dnsmasq status" 2>&1)
            local dns_status_exit=$?
            
            if [ $dns_status_exit -ne 0 ] && echo "$dns_status_log" | grep -qiE "stopped|not running|inactive|dead"; then
              echo "❌ dnsmasq服务启动后未处于运行状态！"
              echo "状态查询日志详情："
              echo "$dns_status_log"
              return 1
            fi
            echo "✅ dnsmasq服务已处于正常运行状态"

            echo -e "\n========== dnsmasq 所有检查项均通过 =========="
            return 0
          }
          
          # 执行dnsmasq服务检查，失败则终止构建
          if ! check_dnsmasq_service; then
            echo "构建终止：dnsmasq 服务检查未通过（服务无法启动）"
            umount_chroot_env rootfs
            exit 1
          fi
          # ===================== 所有检查逻辑结束 =====================
          
          # 5. 额外加固：创建 ppp.wan 符号链接 (非常重要)
          if [ -e rootfs/etc/init.d/ppp ]; then
            ln -sf ppp rootfs/etc/init.d/ppp.wan
          fi

          # 检测自定义效果
          cat rootfs/etc/nftables.d/00-vars.nft
          
          # 6. 环境清理
          umount_chroot_env rootfs
          rm -f rootfs/setup-alpine.sh
          rm -f rootfs/etc/resolv.conf
        '

    - name: Create rootfs package
      id: create_rootfs_package
      run: |
        sudo -u root bash -c '
          cd project
          rootfs_filename="rootfs.tgz"
          tar cvzf ../artifact/${rootfs_filename} rootfs
          echo "##[set-output name=rootfs_filename;]$rootfs_filename"
        '

    - name: Upload rootfs package
      uses: svenstaro/upload-release-action@v2
      with:
        repo_token: ${{ secrets.GITHUB_TOKEN }}
        file: ./artifact/${{ steps.create_rootfs_package.outputs.rootfs_filename }}
        asset_name: ${{ steps.create_rootfs_package.outputs.rootfs_filename }}
        tag: ${{ needs.prepare_release.outputs.release_tag }}
        overwrite: true

  build_img:
    needs: [prepare_release,build_alpine]
    runs-on: ubuntu-22.04
    if: github.event.repository.owner.id == github.event.sender.id

    strategy:
      matrix:
        CPU: [rk3566]
    steps:
    - name: Checkout
      uses: actions/checkout@main

    - name: Initialization environment
      env:
        DEBIAN_FRONTEND: noninteractive
      run: |
        sudo rm -rf /etc/apt/sources.list.d
        wget https://raw.githubusercontent.com/friendlyarm/build-env-on-ubuntu-bionic/master/install.sh
        sed -i -e 's/^apt-get -y install openjdk-8-jdk/# apt-get -y install openjdk-8-jdk/g' install.sh
        sed -i -e 's/^\[ -d fa-toolchain \]/# [ -d fa-toolchain ]/g' install.sh
        sed -i -e 's/^(cat fa-toolchain/# (cat fa-toolchain/g' install.sh
        sed -i -e 's/^(tar xf fa-toolchain/# (tar xf fa-toolchain/g' install.sh
        sudo -E bash ./install.sh
        sudo -E git config --global user.name 'GitHub Actions'
        sudo -E git config --global user.email 'noreply@github.com'
        mkdir -p ./artifact
        sudo swapoff -a
        sudo rm -rf /usr/share/dotnet /usr/local/lib/android/sdk /usr/local/share/boost /opt/ghc
        echo "cores: $(nproc)"
        git clone https://github.com/friendlyarm/prebuilts.git -b master --depth 1
        cd prebuilts/gcc-x64
        sudo tar xf toolchain-11.3-aarch64.tar.xz -C /

    - name: Download alpine rootfs
      uses: robinraju/release-downloader@v1.6
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        repository: ${{ github.repository }}
        tag: ${{ needs.prepare_release.outputs.release_tag }}
        fileName: "rootfs.tgz"

    - name: Build sd image
      id: build_sd_image
      run: |
        mkdir project
        cd project
        case ${{ matrix.CPU }} in
        rk3328)
          BRANCH=kernel-6.6.y
          KERNEL_VARIANT=mainline
          ;;
        rk3528)
          BRANCH=kernel-6.1.y
          KERNEL_VARIANT=vendor
          ;;
        rk3399)
          BRANCH=kernel-6.6.y
          KERNEL_VARIANT=mainline
          ;;
        rk3568)
          BRANCH=kernel-6.1.y
          KERNEL_VARIANT=vendor
          ;;
        rk3566)
          BRANCH=kernel-6.1.y
          KERNEL_VARIANT=vendor
          ;;
        rk3576)
          BRANCH=kernel-6.1.y
          KERNEL_VARIANT=vendor
          ;;
        rk3588)
          BRANCH=kernel-6.1.y
          KERNEL_VARIANT=vendor
          ;;
        *)
          echo "unknow cpu"
          exit 1
          ;;
        esac

        git clone https://github.com/friendlyarm/sd-fuse_${{ matrix.CPU }} -b ${BRANCH} --depth=1 sd-fuse
        sudo su -c "tar xzfp "../rootfs.tgz" -C sd-fuse --numeric-owner --same-owner"
        if [ "${KERNEL_VARIANT}" = "mainline" ]; then
          sudo sed -i 's/ttyFIQ0/ttyS2/g' sd-fuse/rootfs/etc/inittab
        fi

        cd sd-fuse
        sudo -u root bash -c '
          OS_DIR=alpine-linux-arm64
          mkdir ${OS_DIR}

          cp prebuilt/parameter.template ${OS_DIR}/parameter.txt
          # Initialize the size, but it is not the final value, the build-rootfs-img.sh script will overwrite it
          sed -i "s/<ROOTFS_PARTITION_SIZE>/0x000c0000/g" ${OS_DIR}/parameter.txt
          sed -i "s/<USERDATA_PARTITION_ADDR>/0x00106000/g" ${OS_DIR}/parameter.txt

          if [ -f ../../plat/${{ matrix.CPU }}/custom.sh ]; then
            ../../plat/${{ matrix.CPU }}/custom.sh $PWD/rootfs
          fi
          cp -af ../../plat/rockchip-common/alsa/* $PWD/rootfs/

          # build uboot
          UBOOT_SRC=uboot ./build-uboot.sh ${OS_DIR}

          # build kernel
          DISABLE_MKIMG=1 KERNEL_SRC=kernel ./build-kernel.sh ${OS_DIR}
          TMP_DIR=$(mktemp -d out/boot.XXXXXXXXX)
          ./tools/setup_boot_and_rootfs.sh uboot kernel ${TMP_DIR} rootfs ./prebuilt ${OS_DIR}

          # add idbloader.img,boot.img, etc.
          ./tools/update_prebuilt.sh ./${OS_DIR} ./prebuilt

          # build rootfs.img
          ./build-rootfs-img.sh rootfs ${OS_DIR} 0 0
          echo "title=${OS_DIR}" > ./${OS_DIR}/info.conf
          echo "require-board=${{ matrix.CPU }}" >> ./${OS_DIR}/info.conf
          echo "version=$(date +%Y-%m-%d)" >> ./${OS_DIR}/info.conf

          # build sd image
          FILENAME_SD=${{ matrix.CPU }}-sd-alpine-linux-arm64-$(date +%Y-%m-%d).img
          echo "##[set-output name=img_filename_sd;]$FILENAME_SD"
          ./mk-sd-image.sh ${OS_DIR} ${FILENAME_SD}
          mv out/${FILENAME_SD} ../../artifact/

          # build sd-to-emmc image
          FILENAME_SD2EMMC=${{ matrix.CPU }}-eflasher-alpine-linux-arm64-$(date +%Y-%m-%d).img
          echo "##[set-output name=img_filename_sd2emmc;]$FILENAME_SD2EMMC"
          wget http://112.124.9.243/dvdfiles/${{ matrix.CPU }}/images-for-eflasher/emmc-flasher-images.tgz
          tar xzf emmc-flasher-images.tgz
          RAW_SIZE_MB=8000 ./mk-emmc-image.sh ${OS_DIR} filename=${FILENAME_SD2EMMC} autostart=yes
          mv out/${FILENAME_SD2EMMC} ../../artifact/

          # package image-assets-xyz.tgz
          IMAGE_ASSETS_PKG=image-assets-${{ matrix.CPU }}.tgz
          echo "##[set-output name=image_assets_pkg_filename;]$IMAGE_ASSETS_PKG"
          mkdir image-assets-${{ matrix.CPU }}
          tar cpzf image-assets-${{ matrix.CPU }}/rootfs.tgz rootfs
          mv ${OS_DIR} image-assets-${{ matrix.CPU }}/
          tar czf ${IMAGE_ASSETS_PKG} image-assets-${{ matrix.CPU }}
          mv ${IMAGE_ASSETS_PKG} ../../artifact/

          cd ../../artifact/
          gzip *.img
        '

    - name: Upload rootfs to release
      uses: svenstaro/upload-release-action@v2
      with:
        repo_token: ${{ secrets.GITHUB_TOKEN }}
        file: ./artifact/${{ steps.build_sd_image.outputs.image_assets_pkg_filename }}
        asset_name: ${{ steps.build_sd_image.outputs.image_assets_pkg_filename }}
        tag: ${{ needs.prepare_release.outputs.release_tag }}
        overwrite: true

    - name: Upload sd image to release
      uses: svenstaro/upload-release-action@v2
      with:
        repo_token: ${{ secrets.GITHUB_TOKEN }}
        file: ./artifact/${{ steps.build_sd_image.outputs.img_filename_sd }}.gz
        asset_name: ${{ steps.build_sd_image.outputs.img_filename_sd }}.gz
        tag: ${{ needs.prepare_release.outputs.release_tag }}
        overwrite: true

    - name: Upload sd-to-emmc image to release
      uses: svenstaro/upload-release-action@v2
      with:
        repo_token: ${{ secrets.GITHUB_TOKEN }}
        file: ./artifact/${{ steps.build_sd_image.outputs.img_filename_sd2emmc }}.gz
        asset_name: ${{ steps.build_sd_image.outputs.img_filename_sd2emmc }}.gz
        tag: ${{ needs.prepare_release.outputs.release_tag }}
        overwrite: true
